---
title: "bayesOmic: Association analysis of
genomic data using a Bayesian shared
component model"
author: "Juan J Abellán, Carlos Abellán, Juan R González*" 
date: "July 14, 2011"
output: 
  rmarkdown::html_vignette: 
    toc: true
vignette: >
  %\VignetteIndexEntry{bayesOmic}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
# 1 Introduction
This document provides an overview of the bayesGen package that is available
at CRAN (http://cran.r-project.org/). The package implements a Bayesian
approach for genetic association studies. We propose a shared-component
model to tease out the genotype information that is common to cases and
controls from the one that is specific to cases. This allows to detect the
SNPs (bayesSNPassoc function) or CNVs (bayesCNVassoc function) that
show the strongest association with the disease. The model can nevertheless
be applied to more than one disease. More detailed information about the
model and assumptions are given in [1] and [3] in the case of analyzing SNPs
or CNVs, respectively. We illustrate how to analyze SNP data by using a
synthetic data set (WTCCC will also be included). The simulated data set
contains information about 72 SNPs in 5 genes. It includes information for
800 individuals divided in 4 populations: controls and 3 type of cases (M1,
M2, and M3). We simulated SNPs from gene 1 to be associated with M1
and SNPs from gene 3 to M3.  
  
# 2 Getting started
The bayesGen package uses JAGS, a program for analysis of Bayesian hierarchical
models using Markov Chain Monte Carlo (MCMC) simulation [5],
to estimate model parameters. The current implementation of bayesGen is
based on JAGS version 1.4.0. JAGS has an R interface rjags that is used
by the package (rjags version 1.0.3-13).  
We start by attaching the required libraries by typing:
```{r warning=TRUE}
library(rjags)
```
Then, the library is loaded by excuting:
```{r}
library(bayesOmic)
```
# 3 Analysis of SNP data
## 3.1 The data
Data can be imported from a text file or can be loaded using snpMatrix
package (to be supplied). We provide a simulated example that can be
loaded by typing:
```{r}
data(sim.data)
```
The package requires to have the case-control status and the SNPs in to
different objects:
```{r}
group <- sim.data$caco
SNPs <- sim.data[, -1]
```
## 3.2 Model parameter estimates
The model can be run by using the function bayesSNPassoc by executing:
```{r}
# mod<-bayesSNPassoc(SNPs, group)
```
This process takes about 5 minutes. To avoid waiting, we have saved the
object mod that can be loaded as:
```{r}
data(mod)
```
The function bayesSNPassoc prepares the data and then calls rjags to
estimate model parameters. We have set up the following default arguments
to be passed through rjags functions:
```{r}
args(bayesSNPassoc)
```
Notice that other arguments realated to MCMC estimation using JAGS can
be passed through this function. More details about them can be obtained
at http://calvin.iarc.fr/ martyn/software/jags/.  

## 3.3 Checking convergence
Before interpreting the simulations obtained from de a posteriori distri bution,
Markov chains convergence migth be verified. This can be done by using
the function checkConvergence. This function has an argument called
type that defines the kind ob plot to be obtained. When type="Markov
chain" (default value) the function calls to plot.mcmc from package coda.
On the other hand, Gelman-Rubin plots are displayed. The function checkConvergence
has another argument, parameter, to indicate the model parameter to be
summaryzed. The default is ’alpha’. For example, Figure 1 can be obtained
by executing:
```{r}
pdf("./figures/fig-check-alpha.pdf")
checkConvergence(mod)
dev.off()
```
Other model parameters (Figure 2) are summaryzed by changing the argument
called parameter.
```{r}
pdf("./figures/fig-check-lambda.pdf")
checkConvergence(mod, parameter = "log-lambda")
dev.off()
```
Gelman-Rubin plot for alpha parameter can be obtained by typing
```{r}
pdf("./figures/fig-check-alpha-GR.pdf")
checkConvergence(mod, type = "Gelman-Rubin")
dev.off()
```
## 3.4 Results
Model parameters (intercept and shared component) can be obtained by
typing:
```{r}
getParameters(mod)
```
On the other hand, specific and shared components can be obtained by
executing
```{r}
#pdf("./figures/fig-specific.pdf")
#plot(mod)
#dev.off()
```
and
```{r}
#pdf("./figures/fig-shared.pdf")
#plot(mod, type = "shared")
#dev.off()
```
respectively.
Figure 4 shows the specific components for each SNP, while Figure 5 gives
the shared components.
Finnally, a hierarchical clustering can be performed by using the predicted
probabilities by typing:
```{r}
library(RColorBrewer)
pdf("./figures/fig-heatmap.pdf")
makeHeatmap(mod)
dev.off()
```
Figure 6 shows a Heatmap were we can observe that groups M1 and M3 are
different from cases and group M1. 

## 3.5 Model Validation
DIC (Deviance Information Criteria) is one of the most used criteria to evaluate
the goodness-of-fit for a given model. We use the function dic.samples
from rjags package to get such information. This deviance can be computed
using two types of penalization depending on the argument type. The classic
penalization proposed by [2] can be obtained by setting type="pD", while
the penalization proposed by [4] can be obtained with type="popt".
```{r}
#dic.samples(mod$model, n.iter = 2000, type = "pD")
```
# 4 Analysis of CNV data
Data can be imported from a text file or can be loaded using snpMatrix
package (to be supplied). We provide a simulated example that can be
loaded by typing:
```{r}
data(armengol)
```
Multiple comparisons problem is address by computing confidence credible
intervals at more stringent level alpha.corrected
```{r}
nCNVs <- ncol(armengol) - 1
alpha.corrected <- (0.05/nCNVs)/2
```
Model parameter estimates are obtained using the function bayesCNVassoc
by executing:
```{r}
# mod.CNV<-bayesCNVassoc(armengol[,1], armengol[-1], method="JAGS", alpha=c(alpha.corrected, alpha.corrected),  n.iter.burn.in = 20000, n.iter = 200000)
```
This process takes about 6-8 minutes depending on the processor. To avoid
waiting, we have saved the object mod.CNV that can be loaded as
```{r}
#data(modCNV)
```
Specific components for each population can be obtained by typing:
```{r}
#mod.CNV
```
The same information can be visually inspected in Figure 7. This figure can
be obtained by executing
```{r}
#pdf("./figures/fig-specific_CNV.pdf")
#plot(mod.CNV)
#dev.off()
```
# 5 Acknowledgments
This work has been partly supported by the Spanish Ministry for Science
and Innovation (MTM2008-02457) and by XXX.  

# References
[1] J. J. Abellan, C Abellan, and J. R. Gonzalez. A Bayesian shared component
model for genome association studies. Technical Report 1120,
COBRA, 2010.  
[2] D.J. DJ Spiegelhalter, N.G. Best, B.P. Carlin, and A. van der Linde.
Bayesian measures of model complexity and fit (with discussion). Journal
of the Royal Statistical Societey Series B, 64:583–639, 2002.  
[3] JR Gonzalez, C Abellan, and JJ Abellan. A bayesian shared component
model to analyze copy number data in genetic studies. Statistics in
Medicine, submitted, 2010.  
[4] M. Plummer. Penalized loss functions for bayesian model comparison.
Biostatistics, 9(3):523–539, 2008.  
[5] Martin Plummer. JAGS version 1.0.3 manual. Available at
http://calvin.iarc.fr/ martyn/software/jags/, April 2009.

